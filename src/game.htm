<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>TARDQUEST</title>
    <style>
        /* ===== Scrollbar CSS ===== */
        /* Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: #fff #000;
        }

        /* Chrome, Edge, and Safari */
        *::-webkit-scrollbar {
            width: 12px;
        }

        *::-webkit-scrollbar-track {
            background: #000;
        }

        *::-webkit-scrollbar-thumb {
            background-color: #000;
            border-radius: 0px;
            border: 0px solid #fff;
        }

        body {
            background: #000;
            color: #fff;
            font-family: monospace;
            white-space: pre;
            padding: 20px;
            display: flex;
            box-sizing: content-box;
        }

        a:visited,
        a:link {
            color: #fff;
        }

        #ui {
            display: flex;
        }

        #game {
            font-size: var(--viewport-font-size);
            white-space: pre-wrap;
            margin-bottom: auto;
            margin-top: var(--viewport-font-size);
        }

        #inventory:not(.hidden),
        #merchant:not(.hidden) {
            width: 100%;
            height: 100%;
            white-space: pre-wrap;
            display: flex;
            flex-direction: column;
        }

        #inventoryList,
        #merchantItemList {
            flex-grow: 1;
        }

        #inventoryList::before,
        #merchantItemList::before {
            content: "[INVENTORY]";
            display: block;
            text-align: center;
        }

        #merchantItemList::before {
            content: "[The MERCHANT]";
        }

        #inventoryItemDescription,
        #merchantItemDescription {
            min-height: 90px;
        }

        #viewportContainer {
            --viewport-font-size: 13px;

            position: absolute;
            /* or absolute/fixed if you want to float it */

            left: 250px;
            top: 140px;
            border: 2px solid #fff;
            padding-top: 10px;
            padding-left: 4px;
            padding-right: 4px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 360px;
            height: 338px;
            /* Match or exceed #game's min-height */
            overflow-y: scroll;
            overflow-x: hidden;
            box-sizing: content-box;
            align-items: center;
            justify-content: space-between;
        }


        #sidePanel {
            margin-left: 0px;
            display: flex;
            flex-direction: column;
        }

        #battleLog,
        #minimap {
            background: #000;
            border: 2px solid #fff;
            padding: 10px;
            width: 570px;
            height: auto;
        }

        #battleLog {
            height: 90px;
            text-overflow: ellipsis;
            word-wrap: break-word;
            white-space: pre-wrap;
            overflow-y: scroll;
        }

        #minimap {
            height: 166px;
            width: 216px;
            padding: 2px;
            white-space: pre;
            font-size: 12px;
            border-top: 0;
        }

        .hidden {
            display: none;
        }

        #inputBox {
            display: none;
            /* This ensures it's hidden initially */
        }

        #inputBox input {
            background-color: black;
            color: white;
            border: none;
            font-size: 13px;
            width: 210px;
            z-index: 9;
        }

        .menus {
            position: absolute;
            border: solid white 2px;
            border-top: 0;
            top: 314px;
            width: 212px;
            height: 163px;
            overflow: hidden;
            /*
                overflow-y: auto;
                overflow-x: hidden;
            */
            line-height: 0px;
            font-size: 10px;
            padding: 4px;
            padding-top: 9px;
        }

        #controls {
            top: 4px;
            left: 4px;
            font-size: 14px;
            white-space: pre;
        }

        .player {
            color: #2aff00;
        }

        .wall {
            color: #e9ff00;
        }

        .explored {
            color: #fff;
        }

        .unexplored {
            color: #545454;
        }

        .exit {
            color: #f00;
        }

        .merchant {
            color: #f7f;
        }

        .tooExpensive {
            color: #f00;
        }

        .alignRight {
            text-align: right;
        }
  </style>
</head>
<body>
  <div class="menus">
        <a href="https://xxthemilkman69xx.neocities.org/dungeon/title.html">TITLE</a>  <a href="https://xxthemilkman69xx.neocities.org/dungeon/game.html">RESET</a>  <a href="#" id="musicToggle">Toggle Music</a>

        <p><strong>KEY</strong></p>
        <p><span class="player">↑</span> Player: It's you!</p>
        <p><span class="wall">#</span> Wall: It's a fucking wall</p>
        <p><span class="exit">E</span> Exit: Touch to descend further</p>
        <p><span class="merchant">M</span> Merchant: Sells you crap</p>
        <p>H Healing Tile: Heals you to max HP</p>
        <p><span class="unexplored">?</span> Undiscovered: Who knows?</p>
      </div>
  <div id="viewportContainer">
    <div id="controls"></div>
    <div id="game"></div>
    <div id="inventory" class="hidden">
        <div id="inventoryList"></div>
        <div id="inventoryItemDescription"></div>
        <div class="alignRight">Press Escape to exit the Inventory</div>
    </div>
    <div id="merchant" class="hidden">
        <div id="merchantItemList"></div>
        <div id="merchantItemDescription"></div>
        <div class="alignRight">Press Escape to leave the Merchant</div>
    </div>
  </div>
  <div id="ui">
    <div id="sidePanel">
      <div id="battleLog"></div>
      <div id="minimap"></div>
      <div id="inputBox">
        <input type="text" id="persuadeInput" placeholder="Say your piece...">
      </div>
    </div>
  </div>

    <script>
        const
            WIDTH = 30,
            HEIGHT = 11;
        const DIRECTIONS = ['N', 'E', 'S', 'W'];
        const DX = [0, 1, 0, -1];
        const DY = [-1, 0, 1, 0];
        let seenTiles = Array.from({
            length: HEIGHT
        }, () => Array(WIDTH).fill(false));

        const player = {
            x: 1,
            y: 1,
            bitcoins: 0,
            dir: 0,
            hp: 20,
            maxHp: 20,
            defense: 5,
            persuasion: 5,
            exp: 0,
            level: 1,
            inCombat: false,
            isVisitingMerchant: false,
            levelingUp: false,
            inventory: {
                isOpen: false,
                selectionIndex: 0,
                contents: {
                    canOfHamms: 2,
                    cupOfLean: 2,
                    torch: 2,
                    brickOfC4: 2,
                    dowsingRod: 2,
                },
            },
            weapon: 'pointyStick',
            armor: 'graphicTee',
        };

        const merchant = {
            isAlive: true,
            isActiveOnFloor: false,
            x: WIDTH - 2,
            y: HEIGHT - 2,
            selectionIndex: 0,
            items: [],
        };

        const enemies = [
            {
                id: "snailSentinel",
                name: "SNAIL SENTINEL",
                hp: 10,
                attack: [1, 4],
                bitcoins: 4,
            },
            {
                id: "stupidDog",
                name: "STUPID DOG",
                hp: 6,
                attack: [2, 5],
                bitcoins: 3,
            },
            {
                id: "wangRat",
                name: "WANG RAT",
                hp: 5,
                attack: [3, 5],
                bitcoins: 2,
            },
            {
                id: "keeperOfTheToiletBowl",
                name: "KEEPER OF THE TOILET BOWL",
                hp: 15,
                attack: [3, 7],
                bitcoins: 5,
            },
            {
                id: "mysteriousScooter",
                name: "MYSTERIOUS SCOOTER",
                hp: 12,
                attack: [3, 6],
                bitcoins: 4,
            },
            {
                id: "badassFlamingSkeleton",
                name: "BADASS FLAMING SKELETON",
                hp: 13,
                attack: [4, 9],
                bitcoins: 4,
            },
            {
                id: "fridgeOfForgottenLeftovers",
                name: "FRIDGE OF FORGOTTEN LEFTOVERS",
                hp: 20,
                attack: [2, 3],
                bitcoins: 3,
            },
            {
                id: "lughead",
                name: "LUGHEAD",
                hp: 18,
                attack: [2, 6],
                bitcoins: 4,
            },
            {
                id: "pissedOffPoultry",
                name: "PISSED-OFF POULTRY",
                hp: 7,
                attack: [2, 5],
                bitcoins: 2,
            },
            {
                id: "krampusElf",
                name: "KRAMPUS ELF",
                hp: 7,
                attack: [3, 4],
                bitcoins: 4,
            },
        ];
        const defeatMessages = [
          "was beaten to a fucking pulp!",
          "had their bollocks slammed against the hard concrete wall!",
          "got their face scraped along the floor!",
          "died from a nosebleed. Alright then?",
          "was pulverized before they could activate ther anti-retard orbital laser.",
          "pancaked their diaper and died from embarassment. Gross.",
          "left the server.",
          "picked their nose, and died picking their nose.",
          "got bored and jumped down a 'bottomless' hole. You heard a scream, and the sound was absolutely not faint."
        ];

        const weapons = {
            pointyStick: {
                name: "POINTY STICK",
                description: "A stick that fell off of a tree somewhere",
                damage: {
                    base: 2,
                    randomMultiplier: 5,
                },
                price: {
                    buy: 20,
                    sell: 5,
                },
            },
            wiffleBallBat: {
                name: "WIFFLE BALL BAT",
                description: "A hollow bat made of plastic",
                damage: {
                    base: 3,
                    randomMultiplier: 6,
                },
                price: {
                    buy: 50,
                    sell: 20,
                },
            },
            nunchucks: {
                name: "NUNCHUCKS",
                description: "Two pieces of wood connected by a chain",
                damage: {
                    base: 6,
                    randomMultiplier: 9,
                },
                price: {
                    buy: 100,
                    sell: 50,
                },
            },
            atlatlSpear: {
                name: "ATLATL SPEAR",
                description: "A spear with a throwing lever",
                damage: {
                    base: 10,
                    randomMultiplier: 11,
                },
                price: {
                    buy: 400,
                    sell: 200,
                },
            },
            bludgeoningMace: {
                name: "BLUDGEONING MACE",
                description: "A stick with a spikey metal ball at the end of it",
                damage: {
                    base: 10,
                    randomMultiplier: 14,
                },
                price: {
                    buy: 500,
                    sell: 220,
                },
            },
        };

        const armor = {
            graphicTee: {
                name: "GRAPHIC TEE",
                description: "A t-shirt with the text 'Normal people scare me'",
                defense: 1,
                price: {
                    buy: 20,
                    sell: 5,
                },
            },
            barrelWithSuspenders: {
                name: "BARREL (with suspenders)",
                description: "An empty barrel that covers your torso and legs somewhat. Smells like whisky too!",
                defense: 3,
                price: {
                    buy: 50,
                    sell: 30,
                },
            },
            leatherArmor: {
                name: "LEATHER ARMOR",
                description: "The finest in leather, fitted with a tight top, codpiece, cat o' nine tails... (uh, are you sure this is actually armor?)",
                defense: 6,
                price: {
                    buy: 150,
                    sell: 25,
                },
            },
            milaneseArmor: {
                name: "MILANESE ARMOR",
                description: "A classic suit of armor. Looks kind of like a Renaissance-era Robocop",
                defense: 12,
                price: {
                    buy: 1000,
                    sell: 600,
                },
            },
        };

        const items = {
            canOfHamms: {
                name: "CAN OF HAMM'S",
                description: "A warm can of beer. Delicious..? Heals +5 HP",
                use: () => {
                    healPlayer(5);
                    updateBattleLog("You chug the can, filling your mouth with the flavor of boiled socks. +5 HP");
                },
                merchantStockChance: 0.9,
                price: {
                    buy: 10,
                    sell: 5,
                },
            },
            cupOfLean: {
                name: "CUP OF LEAN",
                description: "A crusty styrofoam cup filled with a strange purple syrup. Heals +20 HP",
                use: () => {
                    healPlayer(20);
                    updateBattleLog("Your stomach feels nauseous, but your head feels great! +20 HP");
                },
                merchantStockChance: 0.5,
                price: {
                    buy: 30,
                    sell: 15,
                },
            },
            dowsingRod: {
                name: "DOWSING ROD",
                description: "A Y-shaped stick. Reveals the exit of the current floor",
                use: () => {
                    useDowsingRod();
                    updateBattleLog("The exit has been revealed!");
                },
                merchantStockChance: 0.8,
                price: {
                    buy: 20,
                    sell: 10,
                },
            },
            torch: {
                name: "TORCH",
                description: "An unlit torch. Using it will reveal the map of the current floor",
                use: () => {
                    revealMap();
                    playSFX('torch');
                    updateBattleLog("Lo, the way has been made clear!");
                },
                merchantStockChance: 0.8,
                price: {
                    buy: 60,
                    sell: 30,
                },
            },
            brickOfC4: {
                name: "BRICK OF C-4",
                description: "An incendiary plastic explosive. Great for turning anything into nothing real quick",
                use: () => useC4(),
                merchantStockChance: 0.5,
                price: {
                    buy: 300,
                    sell: 150,
                },
            },
        };

        function healPlayer(hp) {
            player.hp = Math.min(player.maxHp, player.hp + hp);
        }

        function useDowsingRod() {
            for (let y=0; y<MAP.length; y++) {
                for (let x=0; x<MAP[y].length; x++) {
                    if (MAP[y][x] === 'E') {
                        revealMapSpot(x, y, 1);

                        // Since there's only one exit per floor, we can render and exit early
                        render();
                        return;
                    }
                }
            }
        }

        function revealMapSpot(x, y, radius) {
            for (let py=y-radius; py<=y+radius; py++) {
                for (let px=x-radius; px<=x+radius; px++) {
                    if (typeof MAP[py]?.[px] !== 'undefined') {
                        seenTiles[py][px] = true;
                    }
                }
            }
        }

        function revealMap() {
            seenTiles = seenTiles.map((col) => col.map((cell) => true));
            render();
        }

        function useC4() {
            playSFX('explosion');

            if (player.inCombat) {
                const dmg = Math.max(20, Math.round(Math.random() * 10) * 5);
                currentEnemy.hp -= dmg;
                updateBattleLog(`You exploded the shit out of ${currentEnemy.name} for ${dmg} HP!!!`);
                endOfPlayerTurn();
            } else {
                explodePath();
                updateBattleLog("KABOOM! The dungeon walls crumble like charred toast!");
                render();
            }
        }

        function explodePath() {
            let xMin = player.x, xMax = player.x,
                yMin = player.y, yMax = player.y;

            switch (DIRECTIONS[player.dir]) {
                case 'N':
                    xMin--;
                    xMax++;
                    yMin -= 3;
                    break;
                case 'E':
                    yMin--;
                    yMax++;
                    xMax += 3;
                    break;
                case 'S':
                    xMin--;
                    xMax++;
                    yMax += 3;
                    break;
                case 'W':
                    yMin--;
                    yMax++;
                    xMin -= 3;
                    break;
            }

            for (let y=yMin; y<=yMax; y++) {
                for (let x=xMin; x<=xMax; x++) {
                    breakMap(x, y);
                }
            }
        }

        function breakMap(x, y) {
            if (coordsInBounds(x, y)) {
                if (MAP[y][x] === '#') {
                    MAP[y][x] = '.';
                }

                const killedMerchant =
                    merchant.isAlive &&
                    merchant.isActiveOnFloor &&
                    merchant.x === x && merchant.y === y;
                if (killedMerchant) {
                    merchant.isAlive = false;
                    merchant.isActiveOnFloor = false;
                    playSFX('scream');
                    updateBattleLog('MERCHANT: "AIEEEEEEEEEEEEEE!"');
                    updateBattleLog('HOLY SHIT! The merchant has been vaporized into a bloody red mist!');
                }

                seenTiles[y][x] = true;
            }
        }

        function openInventory() {
            player.inventory.isOpen = true;
            player.inventory.selectionIndex = 0;

            document.querySelectorAll('#controls, #game').forEach((el) => {
                el.classList.add('hidden');
            });

            document.getElementById('inventory').classList.remove('hidden');
            document.getElementById('inventoryItemDescription').textContent = '';

            if (isEmpty(player.inventory.contents)) {
                const flavorText = [
                    'Your pockets echo',
                    'You own nothing. Klaus Schwab would be proud',
                    'You got nothin\', bub',
                    'A moth flutters out from your pockets',
                    'What are you doing staring into an empty bag? Go get some items! This is a dungeon crawler for fuck\'s sake!!!',
                    'Your inventory is full of your hopes, dreams, and amibitions',
                ];
                document.getElementById('inventoryList').textContent = flavorText[Math.floor(Math.random() * flavorText.length)];
            }

            renderInventory();
        }

        function closeInventory() {
            document.getElementById('inventory').classList.add('hidden');

            document.querySelectorAll('#controls, #game').forEach((el) => {
                el.classList.remove('hidden');
            });

            player.inventory.isOpen = false;
        }

        function visitTheMerchant() {
            player.isVisitingMerchant = true;
            merchant.items.selectionIndex = 0;

            document.querySelectorAll('#controls, #game').forEach((el) => {
                el.classList.add('hidden');
            });

            document.getElementById('merchant').classList.remove('hidden');
            document.getElementById('merchantItemDescription').textContent = '';

            updateBattleLog('MERCHANT: "Welcome to SlobMart!"');

            renderMerchant();
        }

        function setMerchantWares() {
            const itemKeys = Object.keys(items);
            if (itemKeys.length === 0) {
                console.error("Where the fuck did the items go?");
                return;
            }

            do {
                merchant.items = [];
                itemKeys.forEach((key) => {
                    if (Math.random() < items[key].merchantStockChance) {
                        merchant.items.push(key);
                    }
                });
            } while (merchant.items.length === 0);
        }

        function leaveTheMerchant() {
            document.getElementById('merchant').classList.add('hidden');

            document.querySelectorAll('#controls, #game').forEach((el) => {
                el.classList.remove('hidden');
            });

            player.isVisitingMerchant = false;
            updateBattleLog('MERCHANT: "Thank you. Come again!"');
        }

        const sfx = {
            footstep: new Audio('https://files.catbox.moe/o0ka4u.wav'),
            turn: new Audio('https://files.catbox.moe/heur5b.wav'),
            attack: new Audio('https://files.catbox.moe/0ggtsm.wav'),
            run: new Audio('https://files.catbox.moe/f6eyem.wav'),
            persuade: new Audio('https://files.catbox.moe/e7n7vo.wav'),
            explosion: new Audio('https://files.catbox.moe/jhaqzp.mp3'),
            scream: new Audio('https://files.catbox.moe/j2oegh.mp3'),
            kaching: new Audio('https://files.catbox.moe/02ht6d.mp3'),
            torch: new Audio('https://files.catbox.moe/b2jzsn.mp3'),
        };

        const music = {
            exploration: new Audio('https://files.catbox.moe/hmgkva.wav'),
            battle: new Audio('https://files.catbox.moe/3ajd4i.mp3'),
        };
        music.exploration.loop = true;
        music.battle.loop = true;

        let currentMusic = null;
        let currentEnemy = null;
        let party = [];
        let gameOver = false;
        let awaitingPersuasionText = false;
        let speakingOutsideCombat = false;
        let battleLog = [];
        let floor = 1;
        let MAP = [];
        let exit = {
            x: WIDTH - 2,
            y: HEIGHT - 2
        };

        function generateMap() {
            setExitPosition();

            // Fill in walls
            for (let y = 0; y < HEIGHT; y++) {
                MAP[y] = [];
                for (let x = 0; x < WIDTH; x++) {
                    MAP[y][x] = '#';
                    seenTiles[y][x] = false;
                    // Uncomment this to see the full map
                    // seenTiles[y][x] = true;
                }
            }

            // Carve out a path
            let position = {
                x: player.x,
                y: player.y,
            };

            let stack = null;
            do {
                stack = carvePath([position]);
            } while (stack === null);

            for (let i in stack) {
                MAP[stack[i].y][stack[i].x] = '.';
            }

            for (let i=0; i<10; i++) {
                dissolveMap();
            }

            MAP[player.y][player.x] = '.';
            MAP[exit.y][exit.x] = 'E';

            merchant.isActiveOnFloor = merchant.isAlive && Math.random() < 0.25;
            if (merchant.isActiveOnFloor) {
                setMerchant();
            }
        }

        /**
         * Places the exit based on the player's current position
         *
         * This will set the exit in either the opposite side or opposite corner
         * of where the player currently resides on the map
         */
        function setExitPosition() {
            const margin = 2;
            const possiblePositions = [['x', 'y'], ['x'], ['y']];
            const positions = possiblePositions[
                Math.floor(Math.random() * possiblePositions.length)
            ];

            for (let p in positions) {
                if (positions[p] === 'x') {
                    const exitOffsetX = Math.round(Math.random() * Math.round(WIDTH / 10));
                    if (player.x < WIDTH / margin) {
                        // Player is on the left side of the map
                        // Put the exit on the right
                        exit.x = WIDTH - margin - exitOffsetX;
                    } else {
                        // Player is on the right side of the map
                        // Put the exit on the left
                        exit.x = margin + exitOffsetX;
                    }
                } else {
                    const exitOffsetY = Math.round(Math.random() * Math.round(HEIGHT / 10));
                    if (player.y < HEIGHT / margin) {
                        // Player is at the top of the map
                        // Put the exit on the bottom
                        exit.y = HEIGHT - margin - exitOffsetY;
                    } else {
                        // Player is at the bottom of the map
                        // Put the exit on the top
                        exit.y = margin + exitOffsetY;
                    }
                }
            }
        }

        function setMerchant() {
            setMerchantWares();
            setMerchantPosition();
        }

        function setMerchantPosition() {
            let attempts = 0;

            do {
                const x = Math.floor(Math.random() * WIDTH);
                const y = Math.floor(Math.random() * HEIGHT);

                const isEmptySpace =
                    MAP[y][x] === '.' &&
                    (y !== exit.y && x !== exit.x) &&
                    (y !== player.y && x !== player.x);

                if (isEmptySpace) {
                    merchant.x = x;
                    merchant.y = y;
                    return;
                }
            } while (attempts++ < 1000);

            // If we couldn't place the merchant, don't activate the merchant
            merchant.isActiveOnFloor = false;
        }

        function carvePath(stack) {
            const direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
            const step = Math.random() < 0.5 ? -1 : 1;
            let lastPosition = stack[stack.length - 1];

            for (let i=0; i<2; i++) {
                const nextPosition = {
                    x: lastPosition.x + (direction === 'horizontal' ? step : 0),
                    y: lastPosition.y + (direction === 'vertical' ? step : 0),
                };

                const atMapEdge =
                    nextPosition.x === 0 ||
                    nextPosition.y === 0 ||
                    nextPosition.x === WIDTH - 1 ||
                    nextPosition.y === HEIGHT - 1;

                if (atMapEdge) {
                    return null;
                }

                const alreadyVisited = stack.find((cell) =>
                    cell.x === nextPosition.x && cell.y === nextPosition.y
                );
                if (alreadyVisited) {
                    return null;
                }

                stack.push(nextPosition);

                const reachedEnd =
                    nextPosition.x === exit.x &&
                    nextPosition.y === exit.y;

                if (reachedEnd) {
                    return stack;
                }

                lastPosition = nextPosition;
            }

            let result;
            for (let i=0; i<100; i++) {
                result = carvePath(stack);
                if (result) {
                    break;
                }
            }

            return result;
        }

        function dissolveMap() {
            let dissolvePoints = [];
            for (let y = 2; y < HEIGHT - 2; y++) {
                for (let x = 2; x < WIDTH - 2; x++) {
                    const isDissolvePoint = MAP[y][x] === '#' && (
                        (MAP[y - 1][x] === '#' ? 1 : 0) +
                        (MAP[y + 1][x] === '#' ? 1 : 0) +
                        (MAP[y][x - 1] === '#' ? 1 : 0) +
                        (MAP[y][x + 1] === '#' ? 1 : 0)
                    ) === 3;

                    if (isDissolvePoint) {
                        dissolvePoints.push({x, y});
                    }
                }
            }

            const totalPointsToDissolve = Math.floor(dissolvePoints.length / 2);
            if (totalPointsToDissolve < 1) {
                return;
            }

            for (let i = 0; i < totalPointsToDissolve; i++) {
                const index = Math.floor(Math.random() * dissolvePoints.length);
                const dissolvePoint = dissolvePoints[index];
                MAP[dissolvePoint.y][dissolvePoint.x] = '.';
                dissolvePoints = dissolvePoints.splice(index, 1);
            }
        }

        function updateSeenTiles() {
            seenTiles[player.y][player.x] = true;
            for (let i = 0; i < 4; i++) {
                let nx = player.x + DX[i];
                let ny = player.y + DY[i];
                if (nx >= 0 && ny >= 0 && nx < WIDTH && ny < HEIGHT) {
                    seenTiles[ny][nx] = true;
                }
            }
        }

        function drawMinimap() {
            let out = '';
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    let tile = '';
                    let tileClass = '';
                    if (x === player.x && y === player.y) {
                        const arrow = ['↑', '→', '↓', '←'][player.dir];
                        tile = arrow;
                        tileClass = 'player';
                    } else if (!seenTiles[y][x]) {
                        tile = '?';
                        tileClass = 'unexplored';
                    } else {
                        if (isMerchantTile(x, y)) {
                            tile = 'M';
                            tileClass = 'merchant';
                        } else {
                            switch (MAP[y][x]) {
                                case '#':
                                    tile = '#';
                                    tileClass = 'wall';
                                    break;
                                case 'E':
                                    tile = 'E';
                                    tileClass = 'exit';
                                    break;
                                default:
                                    tile = '.';
                                    tileClass = 'explored';
                            }
                        }
                    }
                    out += `<span class="${tileClass}">${tile}</span>`;
                }
                out += '<br>';
            }
            document.getElementById('minimap').innerHTML = out;
        }

        function isMerchantTile(x, y) {
            return merchant.isActiveOnFloor && x === merchant.x && y === merchant.y;
        }

        function updateBattleLog(entry) {
            battleLog.push(entry);
            if (battleLog.length > 50) {
                battleLog.shift();
            }

            const logContainer = document.getElementById("battleLog");
            logContainer.innerHTML = [...battleLog]
                .slice()
                .reverse()
                .map((msg, i) => {
                    const lightness = 100 - (i * 15); // Fade effect
                    const color = `hsl(0, 0%, ${Math.max(lightness, 50)}%)`; // Prevent it from getting too dark
                    return `<div style="color: ${color};">${msg}</div>`;
                })
                .join("");
        }


        function playMusic(type) {
            if (currentMusic === type) {
                return;
            }

            for (let key in music) {
                music[key].pause();
                music[key].currentTime = 0;
            }
            currentMusic = type;
            music[type].play().catch(err => console.error("Error playing music", err));
        }

        function playSFX(name) {
            if (sfx[name]) {
                sfx[name].currentTime = 0;
                sfx[name].play();
            }
        }

        function wallSlice(d) {
            return {
                3: "||     /#####\\     ||\n",
                2: "||    |#######|    ||\n",
                1: "||   |#########|   ||\n"
            } [d];
        }

        function corridorSlice(d) {
            return {
                3: "||     /     \\     ||\n",
                2: "||    |       |    ||\n",
                1: "||   |         |   ||\n"
            } [d];
        }

        function exitSlice(d) {
            return {
                3: "||     /  E  \\     ||\n",
                2: "||    |   E   |    ||\n",
                1: "||   |    E    |   ||\n"
            } [d];
        }

        function healSlice(d) {
            return {
                3: "||     /  +  \\     ||\n",
                2: "||    |   +   |    ||\n",
                1: "||   |    +    |   ||\n"
            } [d];
        }


        function getEnemyArt() {
            switch (currentEnemy?.id) {
                case "snailSentinel":
                    return `
   ___   |_|
  /   \\_/@ @
__\\_______^/
`;
                case "stupidDog":
                    return `
/\\__/\\
|@  @|
|(00)|
 )vv(
`;
                case "keeperOfTheToiletBowl":
                    return `
   _______
  |       |
  |_______|=)
 -----------         ^
 |         |    O____|
 \\_________/   /|    |
    |   |       |    |
    |___|      / \\   |
`;
                case "mysteriousScooter":
                    return `
       [~~]=====[~~]
            ||
            ||
            ||
            ||
(O)======(O)===O)
`;
                case "badassFlamingSkeleton":
                    return `
      |\\ |\\ |\\ |\\ |\\ /| /|
          _______         /|
    |\\   /   \\   \\      /|
  |\\     | [ ]  [ ]        /|
    |\\   |        |          /|
         \\ \\=====/     //   /|
 |\\       \\______\\    ()/    /|
  |\\       ||        //   /|
     O==[==||==]====O      /|
|\\   || [==||==]       /| /|
  |\\ () [==||==]  /|  /| /|
`;
                case "wangRat":
                    return `
       ______
    (|/      \\|)
      \\O    o/___________________
     --\\-()-/--        __|__|__|_\\
        \\__/__________/
        _|  _|  _|  _|
`;

                case "fridgeOfForgottenLeftovers":
                    return `
            ___.---+.
       .--''       | '.
       |           |  |
       |     ______|  |
       |----'      |  |
       |       [==]|  |
       |           |  |
       |           |  |
       |___        |  |
           '---.___|.-'
`;

                case "lughead":
                    return `
            .--.
            |oO|
         ..-\\TT/-..
        '          '
        ( )      ( )
        ( |------| )
        'W . || . W'
          (__)(__)
`;

                case "pissedOffPoultry":
                    return `
    .        .--.
    |\\      .-:;
    : \\    < O |'
     \\ \\   ;    '.
      \\/\\-(    (. '
      (_)/ -_    ' ;
             '-; ;
            /|\\/|\\
`;

                case "krampusElf":
                    return `
             *
            / \\
        .-./___\\.-.
         \\/ o o \\/
         (__(_)__)
           / : \\
          (_|-|_)
          (__|__)
`;

                default:
                    return '';
            }
        }


        function render() {
            updateSeenTiles();
            drawMinimap();
            let output = "";

            // If the player is leveling up
            if (player.levelingUp) {
                output +=
                    "=== LEVEL UP! ===\nChoose a stat to increase:\nH: Max HP\nD: Defense\nP: Persuasion\n";
                document.getElementById('game').textContent = output;
                return;
            }

            // If the player is in combat
            if (player.inCombat) {
                output +=
                    `+-----------------------+\n${getEnemyArt()}\n+-----------------------+\n`;
                output +=
                    `A wild ${currentEnemy.name} appears\n\nLVL: ${player.level}  EXP: ${player.exp}/${player.level * 10}\n`;
                output +=
                    `HP: ${player.hp} DEF: ${player.defense} PRS: ${player.persuasion}\n`;

                if (party.length > 0) {
                    output += `\nYour Party:\n`;
                    party.forEach(member => {
                        output += `- ${member.name} (HP: ${member.hp})\n`;
                    });
                }

                if (!awaitingPersuasionText) {
                    document.getElementById("controls").textContent =
                        "A: Attack | R: Run | P: Persuade";
                }
            } else {
                // Exploration mode
                for (let d = 3; d >= 1; d--) {
                    let tx = player.x + DX[player.dir] * d;
                    let ty = player.y + DY[player.dir] * d;
                    let tile = getTile(tx, ty);
                    output += tile === '#' ? wallSlice(d) :
                        tile === 'E' ? exitSlice(d) :
                        tile === 'H' ? healSlice(d) :
                        corridorSlice(d);
                }
                output +=
                    "||                 ||\n||   Welcome to... ||\n++----TARDQUEST----++\n" +
                    `LV: ${player.level}  EXP: ${player.exp}/${player.level * 10}  ${DIRECTIONS[player.dir]}\n` +
                    `HP: ${player.hp} DEF: ${player.defense} PRS: ${player.persuasion}\n` +
                    `       BTC: ${player.bitcoins}`;

                if (party.length > 0) {
                    output += `\nYour Party:\n`;
                    party.forEach(member => {
                        output += `- ${member.name} (HP: ${member.hp})\n`;
                    });
                }

                document.getElementById("controls").textContent = "↑/W:      Move Forward\n↓/S:      Move Backward\n←/A, →/D: Turn\nT:        Talk\nI:        Inventory";
            }

            if (player.hp <= 0) {
                output += `\nGood job! You died on floor ${floor}.`;
                gameOver = true;
                setTimeout(() => window.location.href = "https://xxthemilkman69xx.neocities.org/dungeon/title.html", 5000);
            }

            document.getElementById('game').textContent = output;
        }

        function renderInventory() {
            if (isEmpty(player.inventory.contents)) {
                return;
            }

            let i = 0;
            let inventoryText = "";

            for (const property in player.inventory.contents) {
                const isSelectedLine = i++ === player.inventory.selectionIndex;
                const dotPattern = items[property].name.length % 2 ? ' .' : '. ';

                const inventoryLine =
                    (isSelectedLine ? "▶ " : "  ") +
                    (items[property].name + dotPattern.repeat(10)).substr(0, 20) +
                    `${player.inventory.contents[property]}x\n`;

                inventoryText += inventoryLine;

                if (isSelectedLine) {
                    document.getElementById('inventoryItemDescription').textContent = items[property].description;
                }
            }

            document.getElementById('inventoryList').textContent = inventoryText;
        }

        function renderMerchant() {
            let i = 0;
            let itemHtml = player.bitcoins > 0
                ? `You have ${player.bitcoins} BTC in your wallet\n\n`
                : "Your wallet is emptier than a lughead's skull. But you can still look around\n\n";

            merchant.items.forEach((property) => {
                const isSelectedLine = i++ === merchant.selectionIndex;
                const itemTooExpensive = items[property].price.buy > player.bitcoins;
                const dotPattern = items[property].name.length % 2 ? ' .' : '. ';

                const itemLine =
                    (isSelectedLine ? "▶ " : "  ") +
                    (itemTooExpensive ? '<span class="tooExpensive">' : '<span>') +
                    (items[property].name + dotPattern.repeat(10)).substr(0, 20) +
                    `${items[property].price.buy} BTC</span>\n`;

                itemHtml += itemLine;

                if (isSelectedLine) {
                    document.getElementById('merchantItemDescription').textContent = items[property].description;
                }
            });

            document.getElementById('merchantItemList').innerHTML = itemHtml;
        }

        function isEmpty(obj) {
            for (let i in obj) {
                return false;
            }
            return true;
        }

        function getTile(x, y) {
            return !coordsInBounds(x, y) ? '#' : MAP[y][x];
        }

        function coordsInBounds(x, y) {
            return x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT;
        }

        function move(direction) {
            if (player.isVisitingMerchant || player.inCombat || gameOver) {
                return;
            }

            playSFX('footstep');
            let nx, ny, randomEncounterChance;
            if (direction === 'forward') {
                nx = player.x + DX[player.dir];
                ny = player.y + DY[player.dir];
                randomEncounterChance = 0.25;
            } else {
                nx = player.x - DX[player.dir];
                ny = player.y - DY[player.dir];
                randomEncounterChance = 0.5;
            }

            const tile = getTile(nx, ny);
            if (tile !== '#') {
                player.x = nx;
                player.y = ny;
                if (tile === 'H') {
                    player.hp = player.maxHp;
                    MAP[ny][nx] = '.';
                    updateBattleLog("You healed to full HP.");
                } else if (isMerchantTile(nx, ny)) {
                    visitTheMerchant();
                } else if (tile === 'E') {
                    descend();
                } else if (Math.random() < 0.2) {
                    MAP[ny][nx] = 'H';
                } else if (Math.random() < randomEncounterChance) {
                    startEncounter();
                }
            }
        }

        function turnLeft() {
            if (player.inCombat || gameOver) {
                return;
            }

            playSFX('turn');
            player.dir = (player.dir + 3) % 4;
        }

        function turnRight() {
            if (player.inCombat || gameOver) {
                return;
            }

            playSFX('turn');
            player.dir = (player.dir + 1) % 4;
        }

        function startEncounter() {
            currentEnemy = structuredClone(
                enemies[Math.floor(Math.random() * enemies.length)]
            );

            player.inCombat = true;
            party.forEach(member => member.healedThisBattle = false);
            updateBattleLog(`A wild ${currentEnemy.name} appears`);
            playMusic('battle');
        }

        function playerAttack() {
            if (!player.inCombat || awaitingPersuasionText) {
                return;
            }

            playSFX('attack');
            const playerWeapon = weapons[player.weapon];
            const dmg = Math.floor(Math.random() * playerWeapon.damage.randomMultiplier) + playerWeapon.damage.base;
            currentEnemy.hp -= dmg;
            updateBattleLog(`You deal ${dmg} HP to ${currentEnemy.name}`);
            endOfPlayerTurn();
        }

        function endOfPlayerTurn() {
            party.forEach(member => {
                if (!member.healedThisBattle && Math.random() < 0.2) {
                    let healed = Math.ceil(player.maxHp * 0.02);
                    player.hp = Math.min(player.maxHp, player.hp + healed);
                    member.healedThisBattle = true;
                    updateBattleLog(
                        `${member.name} tended your wounds (+${healed} HP)`
                    );
                }
            });

            if (currentEnemy.hp <= 0) {
                const exp = 5;
                const randomMsg = defeatMessages[Math.floor(Math.random() * defeatMessages.length)];
                updateBattleLog(`${currentEnemy.name} ${randomMsg}`);
                updateBattleLog(`You gained +${exp} EXP and ${currentEnemy.bitcoins} BTC`);
                player.inCombat = false;
                player.bitcoins += currentEnemy.bitcoins;
                currentEnemy = null;
                player.exp += exp;
                playMusic('exploration');
                party = party.filter(a => a.hp > 0);
                if (player.exp >= player.level * 10) {
                    player.level++;
                    player.levelingUp = true;
                }
            } else {
                enemyAttack();
            }

            render();
        }

        function enemyAttack() {
            const targetAllies = party.filter(a => a.hp > 0);
            if (targetAllies.length && Math.random() < 0.5) {
                const target = targetAllies[
                    Math.floor(Math.random() * targetAllies.length)
                ];
                const dmg = Math.floor(Math.random() * 4) + 1;
                target.hp -= dmg;
                updateBattleLog(
                    `${currentEnemy.name} deals ${dmg} HP to your ${target.name}`
                );
                if (target.hp <= 0) {
                    updateBattleLog(`Your ${target.name} has been eviscerated...`);
                }
            } else {
                const playerArmor = armor[player.armor];
                const dmg = Math.round((Math.floor(Math.random() * 5) + 1) / Math.max(Math.round(Math.random() * playerArmor.defense), 1));
                player.hp -= dmg;
                updateBattleLog(`${currentEnemy.name} deals ${dmg} HP to you`);
                if (player.hp <= 0) gameOver = true;
            }
        }

        function tryRun() {
            if (!player.inCombat || awaitingPersuasionText) {
                return;
            }

            playSFX('run');
            if (Math.random() < 0.5) {
                updateBattleLog("YOU: Gee willikers, I'm outta here!");
                player.inCombat = false;
                currentEnemy = null;
                playMusic('exploration');
            } else {
                updateBattleLog("Couldn't escape!");
                enemyAttack();
            }
            render();
        }

        function tryPersuade(e) {
            e?.preventDefault();
            playSFX('persuade');
            awaitingPersuasionText = true;
        
            // Show the input box
            const inputBox = document.getElementById("inputBox");
            const input = document.getElementById("persuadeInput");
            inputBox.style.display = "flex";
            input.value = "";
        
            // Delay the focus slightly to ensure it's applied after rendering
            setTimeout(() => {
                input.focus();
            }, 10);
        }



        document.getElementById("persuadeInput").addEventListener("keydown", e => {
            if (e.key === "Enter") {
                const message = e.target.value;
                updateBattleLog(`YOU: "${message}"`);
                e.target.value = "";
                awaitingPersuasionText = false;
                document.getElementById("inputBox").style.display = "none";
        
                // ======== Speaking Outside Combat ========
                if (speakingOutsideCombat) {
                    speakingOutsideCombat = false;
        
                    if (party.length > 0) {
                        const responder = party[Math.floor(Math.random() * party.length)];
                        const responses = [
                            "--you pull out your translator-- 'Wow! Please shut the fuck up.'",
                            "--you pull out your translator-- 'Just so you know, we're not even...'",
                            "--you pull out your translator-- 'You can't be fucking serious...'",
                            "--you pull out your translator-- 'I've come for your pickleeee...'",
                            "--you pull out your translator-- 'Hey that's cool and all, but have you ever played SpongeBob SquarePants: Revenge of the Flying Dutchman on the Sony PlayStation 2?",
                            "--they're too busy playing Burnout Revenge on the PS2--",
                            "--they're too busy sexting your mom--",
                            "--they pick their own nose, and then they pick YOUR nose...--",
                            "--you notice them scratching their nuts whilst ignoring your interjection--",
                        ];

                        const reply = responses[Math.floor(Math.random() * responses.length)];
                        updateBattleLog(`${responder.name}: ${reply}`);
                    }
        
                    render();
                    return;
                }
        
                // ======== Persuasion During Combat ========
                const baseChance = 0.1;
                const prsBonus = player.persuasion * 0.03;
                const totalChance = Math.min(0.9, baseChance + prsBonus);
        
                if (Math.random() < totalChance) {
                    const newAlly = {
                        name: currentEnemy.name,
                        hp: Math.floor(currentEnemy.hp / 2),
                        healedThisBattle: false
                    };
                    party.push(newAlly);
                    updateBattleLog(`${currentEnemy.name} is now following your trail of sweat.`);
                    player.inCombat = false;
                    currentEnemy = null;
                    playMusic('exploration');
                } else {
                    updateBattleLog(`${currentEnemy.name} really, quite genuinely, does not care...`);
                    enemyAttack();
                }
        
                render();
            }
        });



        function handleLevelUpInput(key) {
            switch (key) {
                case 'h':
                    player.maxHp += 5;
                    break;
                case 'd':
                    player.defense += 2;
                    break;
                case 'p':
                    player.persuasion += 2;
                    break;
                default:
                    return;
            }
            player.hp = player.maxHp;
            player.exp = 0;
            player.levelingUp = false;
            render();
        }

        function handleInventoryInput(key) {
            const idx = player.inventory.selectionIndex;
            const items = Object.keys(player.inventory.contents);

            switch (key) {
                case 'i':
                case 'escape':
                    closeInventory();
                    break;
                case 'w':
                case 'arrowup':
                    player.inventory.selectionIndex = idx === 0
                        ? items.length - 1
                        : idx - 1;
                    break;
                case 's':
                case 'arrowdown':
                    player.inventory.selectionIndex = idx === items.length - 1
                        ? 0
                        : idx + 1;
                    break;
                case ' ':
                case 'e':
                case 'enter':
                    useItem(items[player.inventory.selectionIndex]);
                    closeInventory();
                    if (currentEnemy && currentEnemy.hp > 0) {
                        enemyAttack();
                        render();
                    }

                    break;
            }

            renderInventory();
            return;
        }

        function useItem(itemName) {
            items[itemName].use();

            player.inventory.contents[itemName]--;
            if (player.inventory.contents[itemName] <= 0) {
                delete player.inventory.contents[itemName];
            }
        }

        function handleMerchantInput(key) {
            const idx = merchant.selectionIndex;
            const items = merchant.items;

            switch (key) {
                case 'escape':
                    leaveTheMerchant();
                    break;
                case 'w':
                case 'arrowup':
                    merchant.selectionIndex = idx === 0
                        ? items.length - 1
                        : idx - 1;
                    break;
                case 's':
                case 'arrowdown':
                    merchant.selectionIndex = idx === items.length - 1
                        ? 0
                        : idx + 1;
                    break;
                case ' ':
                case 'e':
                case 'enter':
                    buyItem(items[idx]);
                    break;
            }

            renderMerchant();
            return;
        }

        function buyItem(itemKey) {
            const item = items?.[itemKey];
            if (!item) {
                console.error(`${itemKey} doesn't exist!`);
                return;
            }

            if (player.bitcoins < item.price.buy) {
                updateBattleLog('MERCHANT: "Too bad, kid. Come back when you get some coin!"');
                return;
            }

            player.bitcoins -= item.price.buy;
            player.inventory[itemKey] = (player.inventory?.[itemKey] || 0) + 1;

            playSFX('kaching');

            const purchaseFlavorText = [
                "HAHA! You won't regret it!",
                "Don't forget: NO REFUNDS!",
                "You won't find a better deal than this!",
            ];

            const merchantText = purchaseFlavorText[Math.floor(Math.random() * purchaseFlavorText.length)];
            updateBattleLog(`MERCHANT: "${merchantText}"`);

            const itemText = getArticle(item.name) + ' ' + item.name;
            updateBattleLog(`You just bought ${itemText}`);
        }

        function getArticle(noun) {
            return ['a', 'e', 'i', 'o', 'u'].includes(noun.substr(0, 1).toLowerCase()) ? 'an' : 'a';
        }

        document.addEventListener('keydown', e => {
            if (gameOver || awaitingPersuasionText) {
                return;
            }

            const key = e.key.toLowerCase();

            if (player.levelingUp) {
                handleLevelUpInput(key);
                return;
            } else if (player.isVisitingMerchant) {
                handleMerchantInput(key);
                return;
            } else if (player.inventory.isOpen) {
                handleInventoryInput(key);
                return;
            } else if (key === 'i') {
                openInventory();
            } else if (player.inCombat) {
                // Combat mode
                switch (key) {
                    case 'a':
                        playerAttack();
                        break;
                    case 'r':
                        tryRun();
                        break;
                    case 'p':
                        tryPersuade(e);
                        break;
                }
            } else {
                // Exploration mode
                switch (key) {
                    case 'w':
                    case 'arrowup':
                        move('forward');
                        break;
                    case 's':
                    case 'arrowdown':
                        move('backward');
                        break;
                    case 'a':
                    case 'arrowleft':
                        turnLeft();
                        break;
                    case 'd':
                    case 'arrowright':
                        turnRight();
                        break;
                    case 't':
                        speakingOutsideCombat = true;
                        tryPersuade(e);
                        break;
                }
            }

            render();
        });



        function descend() {
            floor++;
            updateBattleLog(`Descending into floor ${floor}...`);
            if (Math.random() < 0.5) {
                const flavorText = [
                    "The stale air fills your nostrils.",
                    "You feel like you're being watched.",
                    "A chill creeps down your spine.",
                    "Your torch flickers strangely in the windless corridor.",
                    "A draft carries the scent of mildew, ash, and Lemon Pledge.",
                    "You hear a dog yipping in the distance.",
                    "An empty snail shell lies cracked on the stairs.",
                    "A growl echoes through the hallway.",
                    "A faint smell of urinal cake wafts up from below.",
                    "You hear a toilet flush in the distance.",
                    "There's graffiti on the wall: \"Beware the snail!\"",
                    "You smell something pungent. Possibly ancient evil. Possibly cheese.",
                    "You hear a groan, as if the dungeon itself is aware of your presence.",
                    "Somewhere ahead, something clanks. You sincerely hope it's plumbing.",
                    "You hear a plunger plunging menacingly.",
                ];

                const logLine = flavorText[Math.floor(Math.random() * flavorText.length)];
                updateBattleLog(logLine);
            }
            generateMap();
        }

        generateMap();
        playMusic('exploration');
        render();
        let musicEnabled = true;

        document.getElementById('musicToggle').addEventListener('click', () => {
            musicEnabled = !musicEnabled;
            const btn = document.getElementById('musicToggle');
            btn.textContent = musicEnabled ? "Toggle Music" :
                "Toggle Music";

            for (let key in music) {
                music[key].muted = !musicEnabled;
                if (!musicEnabled) {
                    music[key].pause();
                } else if (currentMusic) {
                    music[currentMusic].play().catch(err => console.error(
                        "Music play error:", err));
                }
            }
        });
    </script>


</body></html>